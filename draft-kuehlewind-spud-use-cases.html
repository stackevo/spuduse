<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Use Cases for a Substrate Protocol for User Datagrams (SPUD)</title>

<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Firewall Traversal"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Problem Statement"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Information Exposed"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Mechanism"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Deployment Incentives"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Security, Privacy, and Trust"/>
<link href="#rfc.section.3" rel="Chapter" title="3 State Lifetime Discovery"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Problem Statement"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Information Exposed"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Mechanism"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Deployment Incentives"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Security, Privacy, and Trust"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Low-Latency Service"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Problem Statement"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Information Exposed"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Mechanism"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Deployment Incentives"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Security, Privacy, and Trust"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Application-Limited Flows"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Problem Statement"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Information Exposed"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Mechanism"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Deployment Incentives"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Security, Privacy, and Trust"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Priority Multiplexing"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Problem Statement"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Information Exposed"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Mechanism"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Deployment Incentives"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Security, Privacy, and Trust"/>
<link href="#rfc.section.7" rel="Chapter" title="7 In-Band Diagnostics and Measurement"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Problem Statement"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Information Exposed"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Mechanism"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Deployment Incentives"/>
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Security, Privacy, and Trust"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="11 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Kuehlewind, M., Ed. and B. Trammell, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-kuehlewind-spud-use-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-3-18" />
  <meta name="dct.abstract" content="The Substrate Protocol for User Datagrams (SPUD) BoF session at the IETF 92 meeting in Dallas in March 2015 identified the potential need for a UDP-based encapsulation protocol to allow explicit cooperation with middleboxes while using new, encrypted transport protocols. This document summarizes the use cases discuss at the BoF and thereby proposes a structure for the description of further use cases." />
  <meta name="description" content="The Substrate Protocol for User Datagrams (SPUD) BoF session at the IETF 92 meeting in Dallas in March 2015 identified the potential need for a UDP-based encapsulation protocol to allow explicit cooperation with middleboxes while using new, encrypted transport protocols. This document summarizes the use cases discuss at the BoF and thereby proposes a structure for the description of further use cases." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">M. Kuehlewind, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">ETH Zurich</td>
</tr>
<tr>
  <td class="left">Expires: September 19, 2016</td>
  <td class="right">March 18, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Use Cases for a Substrate Protocol for User Datagrams (SPUD)<br />
  <span class="filename">draft-kuehlewind-spud-use-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The Substrate Protocol for User Datagrams (SPUD) BoF session at the IETF 92 meeting in Dallas in March 2015 identified the potential need for a UDP-based encapsulation protocol to allow explicit cooperation with middleboxes while using new, encrypted transport protocols. This document summarizes the use cases discuss at the BoF and thereby proposes a structure for the description of further use cases.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 19, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Firewall Traversal</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Problem Statement</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Information Exposed</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Mechanism</a></li>
<li>2.4.   <a href="#rfc.section.2.4">Deployment Incentives</a></li>
<li>2.5.   <a href="#rfc.section.2.5">Security, Privacy, and Trust</a></li>
</ul><li>3.   <a href="#rfc.section.3">State Lifetime Discovery</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Problem Statement</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Information Exposed</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Mechanism</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Deployment Incentives</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Security, Privacy, and Trust</a></li>
</ul><li>4.   <a href="#rfc.section.4">Low-Latency Service</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Problem Statement</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Information Exposed</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Mechanism</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Deployment Incentives</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Security, Privacy, and Trust</a></li>
</ul><li>5.   <a href="#rfc.section.5">Application-Limited Flows</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Problem Statement</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Information Exposed</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Mechanism</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Deployment Incentives</a></li>
<li>5.5.   <a href="#rfc.section.5.5">Security, Privacy, and Trust</a></li>
</ul><li>6.   <a href="#rfc.section.6">Priority Multiplexing</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Problem Statement</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Information Exposed</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Mechanism</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Deployment Incentives</a></li>
<li>6.5.   <a href="#rfc.section.6.5">Security, Privacy, and Trust</a></li>
</ul><li>7.   <a href="#rfc.section.7">In-Band Diagnostics and Measurement</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Problem Statement</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Information Exposed</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Mechanism</a></li>
<li>7.4.   <a href="#rfc.section.7.4">Deployment Incentives</a></li>
<li>7.5.   <a href="#rfc.section.7.5">Security, Privacy, and Trust</a></li>
</ul><li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a></li>
<li>10.   <a href="#rfc.section.10">Acknowledgments</a></li>
<li>11.   <a href="#rfc.references">Informative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">This document describe use cases for a common Substrate Protocol for User Datagrams (SPUD) that could be used by an overlaying transport or application to explicitely expose information to middleboxes or request information from (SPUD-aware) middleboxes.</p>
<p id="rfc.section.1.p.2">For each use case, we first describe a problem that can not be solved with current protocols, or only solved inefficiently. We then discuss which information should be exposed by which party to help the described problem. We also discuss potential mechanisms to use that exposed information at middleboxes and/or endpoints, in order to demonstrate the feasibility of using the exposed information to the given use case. The described mechanisms are not necessarily proposals for moving forward, nor do  they necessarily represent the best approach for applying the exposed information,  but should illustrate and motivate the applicability of the exposed information.</p>
<p id="rfc.section.1.p.3">In this document we assume that there is no pre-existing trust relationship between the communication endpoints and any middlebox on the path. Therefore we must always assume that information that is exposed can be wrong or nobody will actually act based on the exposed information. However, for the described use cases there should still be a benefit, e.g if otherwise no information would be available.</p>
<p id="rfc.section.1.p.4">Based on each mechanism, we discuss deployment incentives of each involved party. There must be clear incentives for each party to justify the proposed information exposure and at best an incremental deployment strategy. Finally, we discuss potential privacy concerns regarding the information to be exposed, as well as potential security issues of the proposed mechanisms.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#firewall-traversal" id="firewall-traversal">Firewall Traversal</a></h1>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#problem-statement" id="problem-statement">Problem Statement</a></h1>
<p id="rfc.section.2.1.p.1">Today UDP is often blocked by firewalls, or only enabled for a few well-known applications. However, this makes it hard to deploy new services on top of UDP.</p>
<p id="rfc.section.2.1.p.2">For a long time UDP has not been used much for high volume traffic and therefore it was assumed that most UDP traffic is spam or attack traffic. This is not true anymore. The volume of (good) UDP traffic is growing, mostly due to voice and video (real-time) services, e.g. RTCWEB uses UDP for data and media, where TCP is not suitable anyway.</p>
<p id="rfc.section.2.1.p.3">Even if firewall administrators are willing to implement new rules for UDP services, it is hard to track session state for UDP traffic. As UDP is unidirectional, it is unknown whether the receiver is willing to accept the connection. Further there is no way to figure how long state must be maintained once established. To efficiently establish state along the path we need an explicit contract, as is done implicitly with TCP today.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#information-exposed" id="information-exposed">Information Exposed</a></h1>
<p id="rfc.section.2.2.p.1">To maintain state in the network, it must be possible to easily assign each packet to a session that is passing a certain network node. This state should be bound to something beyond the five-tuple to link packets together. In <a href="#I-D.trammell-spud-req">[I-D.trammell-spud-req]</a> we propose the use of identifiers &#8220;tubes&#8221;. This allows for differential treatment of different packets within one five-tuple flow, presuming the application has control over segmentation and can provide requirements on a per-tube basis. Tube IDs must be hard to guess: a tube ID in addition to a five-tuple as an identifier, given significant entropy in the tube ID, provides an additional assurance that only devices along the path or devices cooperating with devices along the path can send packets that will be recognized by middleboxes and endpoints as valid.</p>
<p id="rfc.section.2.2.p.2">Further, to maintain state, the sender must explicitly indicate the start and end of a tube to the path, while the receiver must confirm connection establishment. This, together with the first packet following the confirmation, provides a guarantee of return routability; i.e. that the sender is actually at the address it says it is. This implies all SPUD tubes must be bidirectional, or at least support a feedback channel for this confirmation.  Even though UDP is not a bidirectional transport protocol, often services on top of UDP are bidirectional anyway. Even if not, we only require one packet to acknowledge a new connection. This is low overhead for this basic security feature. This connection set-up should not impose any additional start-up latency, so the sender must be also able to send payload data in the first packet.</p>
<p id="rfc.section.2.2.p.3">If a firewall blocks a SPUD packet, it can be beneficial for the sender to know why the packet was blocked. Therefore a SPUD-aware middlebox should be able to send error messages. Such an error message can either be sent directly to the sender itself, or alternatively to the receiver that can decide to forward the error message to a sender or not.</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#mechanism" id="mechanism">Mechanism</a></h1>
<p id="rfc.section.2.3.p.1">A firewall or middlebox can use the tube ID as an identifier for its session state information. If the tube ID is large enough it will be hard for a non- eavesdropping attacker to guess the ID.</p>
<p id="rfc.section.2.3.p.2">If a firewall receives a SPUD message that signals the start of a connection, it can decide to establish new state for this tube. Alternatively, it can also forward the packet to the receiver and wait if the connection is wanted before establishing state. To not require forwarding of unknown payload, a firewall might want to forward the initial SPUD packet without payload and only send the full packet if the connection has be accepted by the receiver.</p>
<p id="rfc.section.2.3.p.3">The firewall must still maintain a timer to delete the state of a tube if no packets were received for a while. However, if a end signal is received the firewall can remove the state information faster.</p>
<p id="rfc.section.2.3.p.4">If a firewall receives a SPUD message which does not indicate the start of a new tube and no state is available for this tube, it may decide to block the traffic. This can happen if the state has already timed out or if the traffic was rerouted. In addition a firewall may send an error message to the sender or the receiver indicatng that no state information are available. If the sender receives such a message it can resend a start signal (potentially together with other tube state information) and continue its transmission.</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#deployment-incentives" id="deployment-incentives">Deployment Incentives</a></h1>
<p id="rfc.section.2.4.p.1">It is not expected that the provided SPUD information will enable all generic UDP-based services to safely pass firewalls , however, for new services that a firewall administrator is willing to allow, it makes state handling easier.</p>
<p id="rfc.section.2.4.p.2">For application developers that actually would like to use a new transport services, there are today often only two choices; encapsulation over UDP or over TCP. SPUD already provides encapsulation over UDP as well as maintains (a few) additional information about the network state. This shim layer can support application developers to more easily implement new services.</p>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> <a href="#security-privacy-and-trust" id="security-privacy-and-trust">Security, Privacy, and Trust</a></h1>
<p id="rfc.section.2.5.p.1">We proposed to limit the scope of the tube ID to the five-tuple. While this makes the tube ID useless for session mobility, it does mean that the valid ID space is sufficiently sparse to maintain the &#8220;hard to guess&#8221; property, and prevents tube IDs from being misused to track flows from the same endpoint across multiple addresses. This limitation may need further discussion.</p>
<p id="rfc.section.2.5.p.2">By providing information on the connection start up, SPUD only exposes information that are often already given in the higher layer semantics. Thus it does not expose additional information, it only makes the information explicit and accessible without specific higher-layer/application-level knowledge.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#state-lifetime-discovery" id="state-lifetime-discovery">State Lifetime Discovery</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#problem-statement-1" id="problem-statement-1">Problem Statement</a></h1>
<p id="rfc.section.3.1.p.1">Even if the transport protocol implements a close-down mechanism or SPUD explicitly provides an end of tube signal, a network device cannot assume that these signals are provided reliably. Therefore each network device that holds per-flow/per-tube state must implement a mechanism to remove the state if no traffic that is matching this state information has been observer for a while.  Usually this is realized by maintaining a timeout since the last observed packet.</p>
<p id="rfc.section.3.1.p.2">An endpoint that wants to keep a connection open even if it is not sending any data for a while might need to send heartbeat packets to keep state alive that potentially is store somewhere on the network path. However, the timeout period of the network device storing this information is unknow to the endpoint. Therefore it has to send heartbeat fairly rapidly, or might assume a default value of 150ms that is commonly used today.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#information-exposed-1" id="information-exposed-1">Information Exposed</a></h1>
<p id="rfc.section.3.2.p.1">SPUD can be used to request the timeout used by a middlebox. As SPUD-enabled endpoint therefore sends a path-to-endpoint option that is initialized with an non-valid value (e.g. 0) and midpoints can update this information to the timeout value that is used to maintain per-tube state. As multiple network devices might be on a path that maintain per-tube state, the timeout information should only be updated to the minimum value. A sender could also initial the timeout value to the minimum heartbeat frequency it will use or the maximum idle period (if known).</p>
<p id="rfc.section.3.2.p.2">[Editor&#8217;s note: Would it be necessary/useful to get a (separate) confirmation from each middlebox that has understood and read this SPUD information? Alternatively, it would maybe be useful signal the proposed heartbeat period separately, however that&#8217;s also complicated because the endpoint might adapt it&#8217;s heartbeat period based on the timeout information&#8230;]</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#mechanism-1" id="mechanism-1">Mechanism</a></h1>
<p id="rfc.section.3.3.p.1">If a network device that uses a timeout to remove per-tube state receives a SPUD timeout information request, it should expose its own timeout value if smaller than the one already given in the SPUD header. Alternatively, if a value is already given, it might decide to use the given value as timeout for the state information of this tube.</p>
<p id="rfc.section.3.3.p.2">A SPUD sender can request the timeout used by network devices on path to maintain state. If a minimum heartbeat frequency is used or the maximum idle period is known, the sender might pre-set this value. If the pre-set value is not changed, the sender does not know if there is at least one SPUD-aware middlebox on the path that understands the time-out information. In any case a sender must always assume that there could be additional non-SPUD aware middlebox that has a smaller timeout. Therefore even if the proposed timeout is used for heartbeating, traffic can still be blocked due to removed state.  This is also the case if a middlebox did not correctly indicate its timeout value, e.g. when the value is dynamically changed to a smaller value if more state needs to be maintained. However, usually the number of middleboxes on the path that hold per-flow/tube state is low. Therefore the chance that the received feedback indicates the right timeout value is high.</p>
<p id="rfc.section.3.3.p.3">[Editor&#8217;s note: Do we need a SPUD message that can be initialized by the middlebox to et the endpoint know that the time has changed?]</p>
<p id="rfc.section.3.3.p.4">A SPUD endpoint receiving a SPUD header with timeout information should reflect this information to the sender with the next packet that it will be sent (or after a short timeout). Therefore this information should be requested with the first packet, that should immediately trigger the receiver to at least send one packet. In addition SPUD-aware nodes on the backward path are able to also signal their timeout.</p>
<p id="rfc.section.3.3.p.5">[Editor&#8217;s note: Is it necessary to have an explicit SPUD heartbeat packet, that should also be reflected by the receiver to keep state on the backwards path alive..? And then request timeouts for the forward and backward path separately?]</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#deployment-incentives-1" id="deployment-incentives-1">Deployment Incentives</a></h1>
<p id="rfc.section.3.4.p.1">Initially, if not widely deployed, there will be not much benefit to using this extension. However, an endpoint can never be sure that all middleboxes on the path that maintain state information based on a timeout will expose this information (correctly).  An endpoint must always be prepared that traffic can be blocked (after an idle period) and the connection must be restarted. This is the same today if heartbeats are used. Therefore, SPUD will not help to simplify the implementation but it will also no make it much more complicated as only the heartbeat interval might be changed.</p>
<p id="rfc.section.3.4.p.2">However, under the assumption that there are usually only a small number of middbleboxes on one network path that hold (per-tube) state information, it is likely that if information is exposed by a middlebox, this information is correct and can be used.</p>
<p id="rfc.section.3.4.p.3">The more SPUD gets deployed, the more often endpoints will be able to set the heartbeat interval correctly. This will reduce the number of unnecessary reconnects that cause additional latency. Further, an endpoint might be able to request a higher timeout by pre-setting the value.</p>
<p id="rfc.section.3.4.p.4">Network nodes that understand the SPUD timeout information and expose their timeouts are able to handle timeouts more flexibly, e.g. announcing lower timeout values if space is sparse. Further if an endpoint announces a low pre- set value because the endpoint knows that it will only have short idle periods, the timeout interval could be reduced.</p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#security-privacy-and-trust-1" id="security-privacy-and-trust-1">Security, Privacy, and Trust</a></h1>
<p id="rfc.section.3.5.p.1">[Editor&#8217;s note: no trust needed here as discussed above&#8230; right? And I currently don&#8217;t see privacy issues here&#8230;?&#8217;]</p>
<p id="rfc.section.3.5.p.2">[Editor&#8217;s note: Make sure this is not a vector for simplified state exhaustion attacks&#8230;? Don&#8217;t think it&#8217;s worse than TCP&#8230;? Any other attacks?]</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#low-latency-service" id="low-latency-service">Low-Latency Service</a></h1>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#problem-statement-2" id="problem-statement-2">Problem Statement</a></h1>
<p id="rfc.section.4.1.p.1">Networks are often optimized for low loss rates and high throughput by providing large buffers that can absorb traffic spikes or rate variations and always holding enough data to keep the link full. This is beneficial for applications like high-priority bulk transfer, where only the total transfer time is of interest. (High volume) interactive application, such as video calls, however, have very different requirements. Usually these application can tolerate high(er) loss rates, as they anyway cannot wait for missing data to be retransmitted, while having hard latency requirements necessary to make their service work.</p>
<p id="rfc.section.4.1.p.2">Large network buffers may induce high queuing delays due to greedy cross traffic using loss-based congestion control that periodically fills the buffer. In loss-based congestion control the sending rate is periodically increased until a loss is observed to probe for available bandwidth.  Unfortunately, the queuing delay that is indices by this probing can downgrade the quality of experience for competing interactive applications or even make them simply unusable. Further, to co-exist with greedy flows that use loss- based congestion control, one has to react based on the same feedback signal (loss) and implement about the same aggressiveness than these competing flows.</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#information-exposed-2" id="information-exposed-2">Information Exposed</a></h1>
<p id="rfc.section.4.2.p.1">While large buffers that are able to absorb traffic spikes that are often induced by short bursts are beneficial for some applications, the queuing delay that might be induced by these large buffers is very harmful to other applications. We therefore propose an explicit indication of loss- vs.  latency-sensitivity per SPUD tube. This indication does not prioritize one kind of traffic over the other: while loss-sensitive traffic might face larger buffer delay but lower loss rate, latency-sensitive traffic has to make exactly the opposite tradeoff.</p>
<p id="rfc.section.4.2.p.2">Further, an application can indicate a maximum acceptable single-hop queueing delay per tube, expressed in milliseconds. While this mechanism does not guarantee that sent packets will experience less than the requested delay due to queueing delay, it can significantly reduce the amount of traffic uselessly sitting in queues, since at any given instance only a small number of queues along a path (usually only zero or one) will be full.</p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#mechanism-2" id="mechanism-2">Mechanism</a></h1>
<p id="rfc.section.4.3.p.1">A middlebox may use the loss-/latency-sensitive signal to assign packet to the appropriate service if different services are implemented at this middlebox.  Today&#8217;s traffic, that does not indicate a low loss or low latency preference, would still be assigned to today&#8217;s best-effort service, while a new low latency service would be introduced in addition.</p>
<p id="rfc.section.4.3.p.2">The simplest implementation of such a low latency service (without disturbing existing traffic) is to manage traffic with the latency-sensitive flag set in a separate queue. This queue either, in itself, provides only a short buffer which induces a hard limit for the maximum (per-queue) delay or uses an AQM (such as PIE/ CoDel) that is configured to keep the queuing delay low.</p>
<p id="rfc.section.4.3.p.3">In such a two-queue system the network provider must decides about bandwidth sharing between both services, and might or might not expose this information.  Initially there will only be a few flows that indicate low latency preference.  Therefore at the beginning this service might have a low maximum bandwidth share assigned in the scheduler. However, the sharing ratio should be adopted to the traffic load/number of flows in each service class over time. This can be done manually by a network administrator or in an automated way.</p>
<p id="rfc.section.4.3.p.4">Applications and endpoints setting the latency sensitivity flag on a tube must be prepared to experience relatively higher loss rates on that tube, and might use techniques such as Forward Error Correction (FEC) to cope with these losses.</p>
<p id="rfc.section.4.3.p.5">If in addition the maximum per-hop delay is indicated by the sender, a SPUD- aware router might  drop any packet which would be placed in a queue that has more than the maximum single-hop delay at that point in time before queue admission. Thereby the overall congestion can be reduced early instead of withdrawing the packet at the receiver after it has blocked network resources for other traffic. Alternatively, a SPUD-aware node might only remove the payload and add a SPUD error message, to report what the problem is.</p>
<p id="rfc.section.4.3.p.6">An endpoint indicating the maximum per-hop delay must be aware that is might face higher loss rates under congestion than competing traffic on the same bottleneck. Especially, packets might be dropped due to the maximium per-hop delay indication before any congestion notification is given to any other competing flows on the same bottleneck. This should considered in the congestion reaction as any loss should be consider as a sign for congestion.</p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#deployment-incentives-2" id="deployment-incentives-2">Deployment Incentives</a></h1>
<p id="rfc.section.4.4.p.1">Application developers go to a great deal of effort to make latency-sensitive traffic work over today&#8217;s Internet. However, if large delays are induced by the network, an application at the endpoint cannot do much. Therefore applications can benefit from further support by the network.</p>
<p id="rfc.section.4.4.p.2">Network operators have already realized a need to better support low latency services. However, they want to avoid any service degradation for existing traffic as well as risking stability due to large configuration changes.  Introducing an additional service for latency-sensitive traffic that can exist in parallel to today&#8217;s network service (or potentially fully replace today&#8217;s service at some point in future&#8230;) helps this problem.</p>
<h1 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#security-privacy-and-trust-2" id="security-privacy-and-trust-2">Security, Privacy, and Trust</a></h1>
<p id="rfc.section.4.5.p.1">An application does not benefit from wronly indicating loss- or latency- sensitivity as it has to make a tradeoff between low loss and potential high delay or low delay and potential high loss. Therefore there is no incentive for lying. A simple classification of traffic in loss-sensitive and latency- sensitive does not expose privacy-critical information about the user&#8217;s behavior.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#application-limited-flows" id="application-limited-flows">Application-Limited Flows</a></h1>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#problem-statement-3" id="problem-statement-3">Problem Statement</a></h1>
<p id="rfc.section.5.1.p.1">Today, there are a large number of flows that are mostly application-limited, where the application can adapt this limit to changing traffic conditions. An example is unicast streaming video where the coding rate can be adapted based on detected congestion or changing link characteristics. This adaptation is difficult, since cross-traffic (much of which uses TCP congestion control) will often probe for available bandwidth more aggressively than the application&#8217;s control loop. Further complicating the situation is the fact that rate adaptation may have negative effects on the user&#8217;s quality of experience, and should therefore be done infrequently.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#information-exposed-3" id="information-exposed-3">Information Exposed</a></h1>
<p id="rfc.section.5.2.p.1">With SPUD, the sender can provide an explicit indication of the maximum data rate that the current encoding needs. This can provide useful information to the bottleneck to decide how to correctly treat the corresponding tube, e.g.  setting a rate limit or scheduling weight if served from its own queue.</p>
<p id="rfc.section.5.2.p.2">Further, a network node that imposes rate shaping could expose the rate limit to the sender if requested. This would help the sender to choose the right encoding and simplifies probing. If the rate limited is changed the network node might want to signal this change without being requested for it.</p>
<p id="rfc.section.5.2.p.3">In addition, both the endpoint as well as a middlebox could announce sudden changes in bandwidth demand/offer. While for the endpoint it might be most important to indicate that the bandwidth demand has increased, a middlebox could indicate if more bandwidth is (currently) available. Note that this information should only be indicated if the network node was previously the bottleneck/the out-going link is fully loaded. Further, if the information that bandwidth is available is provided to multiple endpoints at the same time, there is a higher risk of overloading the network as all endpoints might increase their rate at the same time.</p>
<p id="rfc.section.5.2.p.4">[Editor&#8217;s note: Should a middlebox even indicate how much capacity is available.. or 1/n of the available capacity if indicated to n endpoints? But there might be a new bottleneck now&#8230;]</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#mechanism-3" id="mechanism-3">Mechanism</a></h1>
<p id="rfc.section.5.3.p.1">If the maximum sending rate of a flow is exposed this information could be used to make routing decision, if e.g. two paths are available that have different link capacity and average load characteristics.</p>
<p id="rfc.section.5.3.p.2">Further, a network nodes, that receives an indication of the maximum rate limit for a certain tube, might decide to threat this flow in an own queue and prioritize this flow in order to keep the delay low as long as the indicated rate limit is not exceeded. This should only be done if there is sufficient capacity on the link (the average load over a previous time period has be low enough to serve an additional maximum traffic load as indicated by the rate limit) or the flow is known to have priority, e.g. based on additional out-of- band signaling. If the link, however, is currently congested, a middlebox might choose to ignore this information or indicate a lower rate limit.</p>
<p id="rfc.section.5.3.p.3">If a network node indicates rate shaping, this information can be used by the sender to choose its current data/coding rate appropriately. However, a sender should still implement a mechanism to probe ifor available bandwidth to verify the provided information. As a certain rate limit is expected the sender should probe carefully around this rate.</p>
<p id="rfc.section.5.3.p.4">A network node might further indicate a different/lower rate limit during the transmission. However, in this case, it might be easy for an attacker to send a wrong rate limit, therefore an endpoint should not change its data rate immediately, but might be prepared to see higher losses rates instead.</p>
<p id="rfc.section.5.3.p.5">If a sender receives an indication that more bandwidth is available it should not just switch to a higher rate but probe carefully. Therefore it might step- wise increase its coding rate or first add additional FEC information which will increase the traffic rate on the link and at the same time provide additional protection as soon as the new capacity limit is reached.</p>
<p id="rfc.section.5.3.p.6">A network node that receives an indication that a flow will increase its rate abruptly, might prioritize this flow for a certain (short) time to enable a smoother transition. [Editor&#8217;s node: Need to figure out if high loss/delay when the coding rate is increased is actually a problem and if so further evaluate if short-term prioritization helps.]</p>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#deployment-incentives-3" id="deployment-incentives-3">Deployment Incentives</a></h1>
<p id="rfc.section.5.4.p.1">By indicating a maximum sending rate a network operator might be able to better handle/schedule the current traffic. Therefore the network operator might be willing to support these kind of flows explicitly by trying to serve the flow with the requested rate. This can benefit the service quality and increase the user&#8217;s satisfaction with the provided network service.</p>
<p id="rfc.section.5.4.p.2">If the maximum sending rate is known by the application, the application might be willing to expose this information if there is a chance that the network will try to support this flow by providing sufficient capacity.</p>
<p id="rfc.section.5.4.p.3">Currently application have no good indication when to change their coding rate. Especially, increasing the rate is hard. Further, it should be avoided to change the rate (forth and back) too often. An indication if and how much bandwidth is available, is therefore helpful for the application and can simplify probing (even though there will still and always be an additional control loop needed to react to congestion and for probing).</p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#security-privacy-and-trust-3" id="security-privacy-and-trust-3">Security, Privacy, and Trust</a></h1>
<p id="rfc.section.5.5.p.1">[Editor&#8217;s note: is there an attack possible by indicating a low limit (from or to the application)? Note, that the application should not rely on this information and still probe for more capacity (if needed) and react to congestion!]</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#priority-multiplexing" id="priority-multiplexing">Priority Multiplexing</a></h1>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#problem-statement-4" id="problem-statement-4">Problem Statement</a></h1>
<p id="rfc.section.6.1.p.1">Many services require multiple parallel transmissions to transfer different kinds of data which usually have a clear priority between each other. One example is WebRTC where the audio is most important and should be higher prioritized than the video, while control traffic might have the lowest priority. Further, some packets within one flow might be more important than others within the same flow/tube, e.g. such as I-frames in video transmissions. However, today a network will treat all packets the same in case of congestion and might e.g. drop audio packets while video and control traffic are still transmitted.</p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#information-exposed-4" id="information-exposed-4">Information Exposed</a></h1>
<p id="rfc.section.6.2.p.1">A SPUD sender may indicate a lower priority relative to another tube that is used in the same 5-tuple.</p>
<p id="rfc.section.6.2.p.2">Similarly, a lower packet priority within one flow/tube could be indicated to give one packet a low priority than other packets with the same tube ID. This information can be used to preferentially drop less inportant packets e.g.  carrying information that could be recovered by FEC or where missing data can be easily concealed.</p>
<p id="rfc.section.6.2.p.3">Further, with a stronger integration of codec and transport technology SPUD could even indicate more even finer grained priority levels to provide automatic graceful degradation of service within the network itself.</p>
<p id="rfc.section.6.2.p.4">[Editor&#8217;s note: do we want to also provide per-packet information over spud? Or would all lower priority packets of one flow simply below to a different tube? In this case can we send a SPUD start message with more than on tube ID?]</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#mechanism-4" id="mechanism-4">Mechanism</a></h1>
<p id="rfc.section.6.3.p.1">Preferential dropping can be implemented by a router queue in case packets need to be dropped due to congestion. In this case the router might not drop the incoming packet but look for a packet with the same tube ID that is already in the queue and has a lower priority than to actual packet that should have been dropped.</p>
<p id="rfc.section.6.3.p.2">Note that a middlebox should only drop a different packet if there is currently a lower priority packet in the queue, because it otherwise does not know whether it will every see a lower priority packet for this flow. This could cause unfairness issues. Therefore a middlebox might need to hold additional state, e.g. keeping position of the last low priority packet of each tube in a separate table. The chance that a low priority packet of the same or corresponding tube currently sits in the queue, is lower the smaller the buffer is. Therefore for low-latency, real-time services, there is a tradeoff.</p>
<p id="rfc.section.6.3.p.3">Alternatively, the middlebox might queue the lower priority traffic in a different queue. Using a different queue might be suitable for lower flow priority but should not be used for lower priority packets within the same flow as this can also lead to other issues such as high reordering. Further, using a lower priority queue will not only give higher priority to the traffic belong to the same service/sender but also to all other competing flows. This is usually not the intention.</p>
<p id="rfc.section.6.3.p.4">[Editor&#8217;s note: Does it makes sense to, in addition, rate-limit the higher prirority flows to their current rate to make sure that the bottleneck is not further overloaded&#8230;?]</p>
<p id="rfc.section.6.3.p.5">If a sender has indicated lower priority to certain tubes and only experiences losses/congestion for the lower priority tubes, the sender should still not increase its sending for the higher priority tube and might even consider to decrease the sending rate for the higher prioroty tubes as well. Potentially a (delay-based) mechanism for shared bottleneck detection should be used to ensure that all transmissions actually share the same bottleneck.</p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#deployment-incentives-4" id="deployment-incentives-4">Deployment Incentives</a></h1>
<p id="rfc.section.6.4.p.1">[Editor&#8217;s note: similar as above -&gt; support of interactive services increases costumer satisfaction&#8230;]</p>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#security-privacy-and-trust-4" id="security-privacy-and-trust-4">Security, Privacy, and Trust</a></h1>
<p id="rfc.section.6.5.p.1">As only lower priority should be indicated, it is harder to use this information for an attack.</p>
<p id="rfc.section.6.5.p.2">[Editor&#8217;s note: Do not really see any trust or privacy concerns here&#8230;?]</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#diag" id="diag">In-Band Diagnostics and Measurement</a></h1>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#problem-statement-5" id="problem-statement-5">Problem Statement</a></h1>
<p id="rfc.section.7.1.p.1">The current Internet protocol stack has very limited facilities for network measurement and diagnostics. The only explicit measurement feature built into the stack is ICMP Echo (&#8220;ping&#8221;), and diagnostic messages derived from ICMP messages may not make it to applications, whether due to the blocking of ICMP traffic for dubious operational reasons or narrow APIs.</p>
<p id="rfc.section.7.1.p.2">In the meantime, the Internet measurement community has defined many inference- and assumption-based approaches for getting better information out of the network: traceroute and BGP looking glasses for topology information, TCP sequence number and TCP timestamp based approaches for latency and loss estimation, and so on. Each of these uses values placed on the wire for the internal use of the protocol, not for measurement purposes, and do not necessarily apply to the deployment of new protocols or changes to the use of those values by protocol implementations. Approaches involving the encryption of transport protocol and application headers (indeed, including that the authors advance in <a href="#I-D.trammell-spud-req">[I-D.trammell-spud-req]</a>) will break most of these, as well.</p>
<p id="rfc.section.7.1.p.3">Replacing the information used for measurement with values defined explicitly to be used for measurement in a transport protocol independent way allows explicit endpoint control of measurability and measurement overhead.</p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#information-exposed-5" id="information-exposed-5">Information Exposed</a></h1>
<p id="rfc.section.7.2.p.1">The &#8220;big five&#8221; metrics &#8211; latency, loss, jitter, data rate / goodput, and reordering &#8211; can be measured using a relatively simple set of primitives.  Packet receipt acknowledgment using a cumulative packet nonce counter allows both endpoint and on-path measurement of loss and reordering as well as goodput (when combined with layer 3 packet length headers). A timestamp echo facility, analogous to TCP&#8217;s timestamp option but using an explicitly defined, constant-rate clock and exposure of local delta (time between receipt and subsequent transmission). In short, the information exposed is no more than that currently exposed by TCP, but defined in a way to be</p>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#mechanism-5" id="mechanism-5">Mechanism</a></h1>
<p id="rfc.section.7.3.p.1">[TODO]</p>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> <a href="#deployment-incentives-5" id="deployment-incentives-5">Deployment Incentives</a></h1>
<p id="rfc.section.7.4.p.1">[TODO]</p>
<h1 id="rfc.section.7.5"><a href="#rfc.section.7.5">7.5.</a> <a href="#security-privacy-and-trust-5" id="security-privacy-and-trust-5">Security, Privacy, and Trust</a></h1>
<p id="rfc.section.7.5.p.1">[TODO]</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">This document has no actions for IANA.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.9.p.1">Security and privacy considerations for each use case are given in the corresponding Security, Privacy, and Trust subsection.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.10.p.1">This document grew in part out of discussions of initial use cases for middlebox  cooperation at the IAB SEMI Workshop and the IETF 92 SPUD BoF; thanks to the participants. <a href="#diag">Section 7</a> is based in part out of discussions and ongoing work with Mark Allman and Rob Beverly.</p>
<p id="rfc.section.10.p.2">This work is supported by the European Commission under Horizon 2020 grant agreement no. 688421 Measurement and Architecture for a Middleboxed Internet (MAMI), and by the Swiss State Secretariat for Education, Research, and Innovation under contract no. 15.0268. This support does not imply endorsement.</p>
<h1 id="rfc.references"><a href="#rfc.references">11.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.hildebrand-spud-prototype">[I-D.hildebrand-spud-prototype]</b>
      </td>
      <td class="top"><a>Hildebrand, J.</a> and <a>B. Trammell</a>, "<a href="http://tools.ietf.org/html/draft-hildebrand-spud-prototype-03">Substrate Protocol for User Datagrams (SPUD) Prototype</a>", Internet-Draft draft-hildebrand-spud-prototype-03, March 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.trammell-spud-req">[I-D.trammell-spud-req]</b>
      </td>
      <td class="top"><a>Trammell, B.</a> and <a>M. K&#252;hlewind</a>, "<a href="http://tools.ietf.org/html/draft-trammell-spud-req-02">Requirements for the design of a Substrate Protocol for User Datagrams (SPUD)</a>", Internet-Draft draft-trammell-spud-req-02, March 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div>

</body>
</html>
